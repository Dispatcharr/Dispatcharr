"""
HLS Output Views

Serves HLS playlists and segments generated by FFmpeg from channels.
"""
import os
import logging
from django.http import FileResponse, HttpResponse, Http404
from django.views.decorators.http import require_http_methods
from core.models import CoreSettings

logger = logging.getLogger(__name__)


@require_http_methods(["GET"])
def serve_master_playlist(request):
    """
    Serve master playlist with all available quality variants.
    
    URL: /hls/master.m3u8
    """
    try:
        # Get HLS output settings
        settings = CoreSettings.get_hls_output_settings()
        storage_path = settings.get('storage_path', '/var/www/hls')
        
        # Build master playlist content
        master_playlist = "#EXTM3U\n"
        master_playlist += "#EXT-X-VERSION:3\n"
        
        # Add variant streams
        master_playlist += '#EXT-X-STREAM-INF:BANDWIDTH=5000000,RESOLUTION=1920x1080,NAME="1080p"\n'
        master_playlist += "1080p.m3u8\n"
        
        master_playlist += '#EXT-X-STREAM-INF:BANDWIDTH=2800000,RESOLUTION=1280x720,NAME="720p"\n'
        master_playlist += "720p.m3u8\n"
        
        master_playlist += '#EXT-X-STREAM-INF:BANDWIDTH=1400000,RESOLUTION=854x480,NAME="480p"\n'
        master_playlist += "480p.m3u8\n"
        
        return HttpResponse(master_playlist, content_type='application/vnd.apple.mpegurl')
        
    except Exception as e:
        logger.error(f"Error serving master playlist: {e}", exc_info=True)
        raise Http404("Master playlist not found")


@require_http_methods(["GET"])
def serve_playlist(request, channel_uuid, quality):
    """
    Serve HLS playlist for a specific channel and quality.
    
    URL: /hls/channel/{channel_uuid}/{quality}.m3u8
    
    Args:
        channel_uuid: UUID of the channel
        quality: Quality variant (1080p, 720p, 480p, copy)
    """
    try:
        # Get HLS output settings
        settings = CoreSettings.get_hls_output_settings()

        # HLS files are always in /data/hls in the container
        storage_path = '/data/hls'

        # Build playlist file path
        playlist_path = os.path.join(storage_path, channel_uuid, f"{quality}.m3u8")
        
        # Check if file exists
        if not os.path.exists(playlist_path):
            logger.warning(f"Playlist not found: {playlist_path}")
            raise Http404(f"Playlist not found for channel {channel_uuid} at quality {quality}")
        
        # Serve the playlist file
        response = FileResponse(
            open(playlist_path, 'rb'),
            content_type='application/vnd.apple.mpegurl'
        )
        
        # Add cache control headers
        cache_ttl = settings.get('playlist_cache_ttl', 2)
        response['Cache-Control'] = f'max-age={cache_ttl}'
        
        return response
        
    except FileNotFoundError:
        logger.error(f"Playlist file not found: {playlist_path}")
        raise Http404(f"Playlist not found for channel {channel_uuid}")
    except Exception as e:
        logger.error(f"Error serving playlist for channel {channel_uuid}: {e}", exc_info=True)
        raise Http404("Error serving playlist")


@require_http_methods(["GET"])
def serve_segment(request, channel_uuid, quality, segment_name):
    """
    Serve HLS segment for a specific channel and quality.
    
    URL: /hls/channel/{channel_uuid}/{quality}/{segment_name}
    
    Args:
        channel_uuid: UUID of the channel
        quality: Quality variant (1080p, 720p, 480p, copy)
        segment_name: Name of the segment file (e.g., 1080p_001.ts)
    """
    try:
        # Get HLS output settings
        settings = CoreSettings.get_hls_output_settings()

        # HLS files are always in /data/hls in the container
        storage_path = '/data/hls'

        # Build segment file path
        segment_path = os.path.join(storage_path, channel_uuid, segment_name)
        
        # Security check: ensure path is within storage directory
        real_segment_path = os.path.realpath(segment_path)
        real_storage_path = os.path.realpath(storage_path)
        
        if not real_segment_path.startswith(real_storage_path):
            logger.warning(f"Attempted path traversal: {segment_path}")
            raise Http404("Invalid segment path")
        
        # Check if file exists
        if not os.path.exists(segment_path):
            logger.warning(f"Segment not found: {segment_path}")
            raise Http404(f"Segment not found: {segment_name}")
        
        # Serve the segment file
        response = FileResponse(
            open(segment_path, 'rb'),
            content_type='video/MP2T'
        )
        
        # Add cache control headers
        cache_ttl = settings.get('segment_cache_ttl', 86400)
        response['Cache-Control'] = f'max-age={cache_ttl}'
        
        return response
        
    except FileNotFoundError:
        logger.error(f"Segment file not found: {segment_path}")
        raise Http404(f"Segment not found: {segment_name}")
    except Exception as e:
        logger.error(f"Error serving segment {segment_name} for channel {channel_uuid}: {e}", exc_info=True)
        raise Http404("Error serving segment")

